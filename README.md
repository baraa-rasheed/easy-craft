# easy-craft

In the document, we'll dive into how did we build easy-craft with use of React Router.

in the `types/routes.ts` you will find how we are defining our routes with their elements.

but first you should be aware of the following react router main points

## React Router main points for creating a route

- `element` prop is for passing a component with it's needed props.
- `path` is the path to reach the required page.
- Omitting the path makes the route a `layout route`.
- `loader` which is a function to provide data to the route element before it renders
- `defer` is a utility allows you to defer values returned from loaders by passing promises instead of resolved values.

## Let's see how we did it?

let's break down our route interface and see what detials does it include

### Route

```
interface IRoute {

  // path of the route
  path: string;

  // icon of the route (it could be displayed in the sidebar or whenever needed)
  icon: string;

  // type is like a section that the route will fill into in the sidebar
  type?: string;

  // title of the page, this could used as the page header
  title: string;

  // here we are definding an array of elements that would be rendered in the <AutoGeneratedPage/>.

  elements: Array<IElement>;
}
```

### Element

```
interface IElement {
  // a uuid for each element on the page
  id: string;

  // api is an object that include all important information for fetching data into the component
  api?: IApi;

  // side of the component: "large"|"medium"|"small" inside of the grid
  size: SIZE;

  // element props that should be passed into the element
  props?: any;

  // the element key, so we know which component to render
  element?: keyof typeof components;
}
```

### Api

```
interface IApi {
  // the api key, so we know which api function should we call
  key: keyof typeof apis;

  // after getting the response from api, we can define this key if we need only this key from the response.
  responseKey?: string;

  // data & params => will be passed into the api function so we can do the appropriate api call. (these are dynamic from the user).

  data?: Record<string, any>;
  params?: Record<string, any>;

  /*
     after getting the response from api and getting the responsekey if needed
     sometimes the data should be modified into different shape that fits our
     elements, so for that we can pass a helper key, so we know which helper
     should we call and pass the response into;
  */
  helperKey?: keyof typeof helpers;

  /*
  this object is responsible for mapping data keys into element props. for / example if the reponse returns the following response {metric:'Analysis'} // and the element has the prop title.
  */
  responseToProps{
    "metric":"title"
  }
  /*
  explination:
  which means pass the response key into that prop for that element
  responseToProps: { [key: string]: string };
  */
}
```
